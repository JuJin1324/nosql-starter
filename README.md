# nosql-starter

## Relational database
### 기존 RDB 의 한계점
> RDB 에 발생할 수 있는 부하는 2가지 있다. 첫번째는 write 에 관한 부하이고 두번째는 read 에 관한 부하이다.  
> read 및 write 공통으로 부하가 발생했을 때 일반적인 해결방법은 DB 서버의 scale-up 이 있다.   
> read 부하를 해결하기 위한 방법으로 Read Replica 를 여러대 생성을 통해서 부하 해결이 가능하다.  
> write 의 부하를 해결하기 위한 방법으로 여러 개의 DB 서버를 sharding 으로 묶어서 해결이 가능하다.
> 위의 두 방법 모두 동적으로 서버를 늘렸다 줄이는 방식인 scale-out 에 유연하지 못하다.  
>
> transaction 이 제공하는 ACID 를 보장하기 위해서 DB 서버의 퍼포먼스에 영향을 미침.  

---

## NoSQL
### 등장 배경
> 대부분이 RDB 가 scale out 이 힘들고 RDB 의 부하 처리 이상의 데이터 트래픽이 발생했을 때 NoSQL 을 등장시켜서
> 문제를 해결하였음.  

### NoSQL 특징
> 1.flexible schema: 스키마 관리를 DB 가 아닌 application 에서 한다.    
> 
> 2.중복 허용(join 회피): 테이블 내의 컬럼이 정규화를 하지 않기 때문에 연관 테이블의 키가 아닌 데이터가 중복되어 들어가고 
> 그로 인하여 해당 연관 테이블의 값이 업데이트된 경우 같이 업데이트 해주어야 한다. 
> 혹은 주문에서의 제품 가격을 생각해보면 제품 A 의 주문 당시 가격이 100원인데 이후 200원이 되었다고 주문 안에서 
> 제품 가격이 변하지는 않는다. 이러한 경우처럼 연관 테이블의 값이 업데이트 되어도 같이 업데이트를 반영할 필요가 없는 경우에 유용할 듯 싶다.  
> 
> 3.scale-out: nosql 은 클러스터링을 구성하여 사용해서 scale-out 에 용이하다.  
> 
> 4.high throughput, low latency: 높은 처리량, 낮은 지연이 특징이다. 단 이를 위해서 데이터의 일관성(consistency)은 잉정부분 떨어질 수 있다.

### 참조 사이트
> [NoSQL 설명!! RDB와는 어떤 차이가 있는지도 설명!! MongoDB, Redis 매우 간단한 예제 포함!!](https://www.youtube.com/watch?v=sqVByJ5tbNA)

## DynamoDB
### 등장 배경
> 기존 Amazon 에서 RDB 만 사용하던 시절에 RDB 에 감당할 수 없는 부하가 발생하였음.
> 그런데 조사를 해보니 부하의 약 90% 정도가 join 이 많은 조회라기 보다는 key value 에 적합한 형태의 데이터 조회였음.
> 그래서 DynamoDB 서비스를 도입하며 런칭함.

### 키 디자인 패턴
> DynamoDB 의 테이블은 기본적으로 3개의 파티션을 갖고 시작한다.  
> 각 파티션은 10GB 까지 데이터를 저장할 수 있으며 10GB 가 넘어간 경우 repartitioning 을 통해서 파티션을 추가해서 기존 데이터를 반으로 나누게 된다.
> 하지만 이 모든 것은 직접 처리하는 것이 아닌 DynamoDB 내부에서 하는 것임으로 신경쓸 것은 없다. (비용만 신경쓴다.)  
> 또한 각 파티션은 1000 WCU/sec 혹은 3000 RCU/sec 를 제공하며 둘 중 하나가 초과되어도 파티션이 늘어난다.  
> 
> DynamoDB 의 키는 Partition Key 와 Sort Key 로 구성된다.  
> Partition Key: 파티션 키에 따라 해당 아이템(row) 을 어느 파티션에 저장할 지 지정된다. 일반적으로 검색에 사용된다.
> equal(=) 연산을 통해서만 검색할 수 있다.  
> Sort Key: 검색으로 사용된 Partition Key 의 아이템 중에서 한 번 더 필터하는 기능 및 정렬하는 기능으로 사용된다.
> begin with, between 등의 조건으로 검색할 수 있다.  
>
> DynamoDB 도 transaction 을 제공한다. 하지만 WCU 및 RCU 를 일반적인 Read/Write 시 보다 더 사용함으로 비용을 고려해서 최소한으로 사용하거나 
> 사용하지 않는 것이 좋겠다.
 
### GSI(Global Secondary Index)  
> RDB 의 인덱스처럼 PK 가 아닌 다른 애트리뷰트(RDB 의 칼럼) 로 조회가 필요할 경우 해당 애트리뷰트에 GSI 를 걸어서 사용할 수 있다.  
> Key/Value DB 의 경우 테이블을 특정 조회 목적에 맞게 설계되는 것이 일반적일 수 있다고 생각한다.  
> 그렇기 때문에 일반적으로 애트리뷰트가 아닌 Key 로만 조회가 가능하도록 애플리케이션을 설계하는 것을 대원칙으로 새워야하며,
> 조회의 기준이 되는 항목이 Key 가 아닌 다른 애트리뷰트로 변경하는 경우에는 테이블을 새로 생성하여 기존 테이블을 마이그레이션하는 방식을 고려하는 것이 현명해보인다.  
> 기존의 Key 를 통해서도 조회가 필요하면서 특정 애트리뷰트를 통해서도 같이 조회가 필요한 경우에는 GSI 를 생성을 고려해볼 수 있겠다.  
> 
> LSI(Local Secondary Index)  
> 테이블 생성 시에만 추가할 수 있는 인덱스로 사실 상 사용을 권장하진 않는다.  
> 위에서도 말했든 Key/Value DB 의 경우 사용하는 애플리케이션에서 Key 를 통해서만 조회를 해도 문제 없도록 Key 설계를 좀 더 세밀하게 할 필요가 있다.  

### Use case best practice  
> DynamoDB 는 저장된 대용량의 데이터를 Key 를 통해서 특정 데이터 하나 또는 몇개의 아이템을 빠르게 조회하는데에 특화되어 있다.   
> 대량의 Range 쿼리, Full Text Search(단어 또는 구문 검색: like 쿼리), 집계 쿼리 용도로는 비효율적이다.  
> 
> DynamoDB 는 정규화된 여러개의 Entity 가 아닌 하나의 큰 테이블을 지향하여 설계해야한다.  
> 또한 RDB 의 정규화 규칙처럼 공식화된 규칙이 있는 것이 아니기 때문에 테이블 디자인은 사람마다 모두 제각각이 될 수 있다.
> DynamoDB 도입을 위해서는 팀에서 설계 -> 리뷰 -> 설계 -> 리뷰 를 반복적으로 하여 모든 팀원이 DynamoDB 테이블 디자인을 공유해야한다.  



